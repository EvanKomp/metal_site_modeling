# metalsitenn/utils.py
'''
* Author: Evan Komp
* Created: 11/26/2024
* Company: National Renewable Energy Lab, Bioeneergy Science and Technology
* License: MIT
'''
import py3Dmol
from typing import Dict, Optional
from metalsitenn.placer_modules.cifutils import Chain
from metalsitenn.constants import I2E
import pandas as pd
import numpy as np
from dataclasses import dataclass
import torch



@dataclass
class ParamsObj:
    """Wraps dict of dicts to allow attribute access to nested dicts."""
    def __init__(self, upper_dict):
        for k, v in upper_dict.items():
            if isinstance(v, dict):
                setattr(self, k, ParamsObj(v))
            else:
                setattr(self, k, v)

    def __getitem__(self, key):
        return getattr(self, key)
    
    def __repr__(self):
        return str(self.__dict__)
    
    def keys(self):
        return self.__dict__.keys()
    
    def values(self):
        return self.__dict__.values()
    
    @property
    def param_names(self):
        return list(self.__dict__.keys())
    
    def copy(self):
        """Return a deep copy of the ParamsObj."""
        import copy
        return copy.deepcopy(self)
    
    def dict(self):
        """Convert ParamsObj back to a nested dictionary."""
        result = {}
        for k, v in self.__dict__.items():
            if isinstance(v, ParamsObj):
                result[k] = v.dict()
            else:
                result[k] = v
        return result
    

def make_jsonable(dic):
    """Convert numerics into int or float for JSON serialization."""
    new_dic = {}
    for k, v in dic.items():
        if isinstance(v, str):
            new_dic[k] = v
        # it may be a numeric but not a base type like numpy or something
        # first check it its a whole number
        if int(v) == v:
            new_dic[k] = int(v)
        else:
            new_dic[k] = float(v)
    return new_dic
         

def chain_to_sdf_string(chain: Chain) -> str:
    """
    Convert a Chain object to SDF (Structure Data Format) string.
    SDF format includes explicit bond information that py3Dmol can parse.
    
    Args:
        chain: Chain object from CIF parser containing atoms and bonds
        
    Returns:
        SDF format string
    """
    
    # Filter atoms with occupancy > 0 and create atom list
    valid_atoms = [(atom_key, atom) for atom_key, atom in chain.atoms.items() if atom.occ > 0]
    
    if not valid_atoms:
        return ""
    
    # Create atom key to index mapping for bond references
    atom_key_to_index = {atom_key: i for i, (atom_key, atom) in enumerate(valid_atoms)}
    
    # SDF Header (molecule name, program info, comment)
    sdf_lines = [
        chain.id or "molecule",  # Molecule name
        "Generated by metalsitenn",  # Program info
        "Converted from CIF Chain object",  # Comment
        ""  # Empty line
    ]
    
    # Counts line: aaabbblllfffcccsssxxxrrrpppiiimmmvvvvvv
    # aaa = number of atoms, bbb = number of bonds
    num_atoms = len(valid_atoms)
    num_bonds = len([b for b in chain.bonds if b.a in atom_key_to_index and b.b in atom_key_to_index])
    
    counts_line = f"{num_atoms:3d}{num_bonds:3d}  0  0  0  0  0  0  0  0999 V2000"
    sdf_lines.append(counts_line)
    
    # Atom block: xxxxx.xxxxyyyyy.yyyyzzzzz.zzzz aaaddccchhhmmmvvvHHHrrriiisssbbbbbbbbbbbbeeeeeeeeeeee
    for atom_key, atom in valid_atoms:
        element_symbol = I2E.get(atom.element, 'X')
        
        # Format coordinates to SDF specification (10.4f format)
        x, y, z = atom.xyz
        atom_line = f"{x:10.4f}{y:10.4f}{z:10.4f} {element_symbol:<3s} 0  {atom.charge:3d}  0  0  0  0  0  0  0  0  0  0"
        sdf_lines.append(atom_line)
    
    # Bond block: 111222tttsssxxxrrrccc
    # 111 = first atom number, 222 = second atom number, ttt = bond type
    for bond in chain.bonds:
        if bond.a in atom_key_to_index and bond.b in atom_key_to_index:
            atom1_idx = atom_key_to_index[bond.a] + 1  # SDF uses 1-based indexing
            atom2_idx = atom_key_to_index[bond.b] + 1
            bond_order = bond.order if hasattr(bond, 'order') and bond.order else 1
            
            # Limit bond order to valid SDF range (1-3, 4 for aromatic)
            if bond.aromatic:
                bond_type = 4
            else:
                bond_type = min(max(bond_order, 1), 3)
            
            bond_line = f"{atom1_idx:3d}{atom2_idx:3d}{bond_type:3d}  0  0  0  0"
            sdf_lines.append(bond_line)
    
    # End of molecule marker
    sdf_lines.append("M  END")
    sdf_lines.append("$$$$")
    
    return '\n'.join(sdf_lines)

def chain_to_mol2_string(chain: Chain) -> str:
    """
    Convert a Chain object to MOL2 format string as an alternative to SDF.
    MOL2 format also includes explicit bond information.
    
    Args:
        chain: Chain object from CIF parser containing atoms and bonds
        
    Returns:
        MOL2 format string
    """
    
    # Filter atoms with occupancy > 0
    valid_atoms = [(atom_key, atom) for atom_key, atom in chain.atoms.items() if atom.occ > 0]
    
    if not valid_atoms:
        return ""
    
    # Create atom key to index mapping
    atom_key_to_index = {atom_key: i for i, (atom_key, atom) in enumerate(valid_atoms)}
    
    mol2_lines = ["@<TRIPOS>MOLECULE"]
    mol2_lines.append(chain.id or "molecule")
    
    num_atoms = len(valid_atoms)
    num_bonds = len([b for b in chain.bonds if b.a in atom_key_to_index and b.b in atom_key_to_index])
    
    mol2_lines.append(f"{num_atoms} {num_bonds} 0 0 0")
    mol2_lines.append("SMALL")
    mol2_lines.append("NO_CHARGES")
    mol2_lines.append("")
    
    # Atom section
    mol2_lines.append("@<TRIPOS>ATOM")
    for i, (atom_key, atom) in enumerate(valid_atoms):
        element_symbol = I2E.get(atom.element, 'X')
        atom_name = atom_key[3] if len(atom_key) > 3 else f"{element_symbol}{i+1}"
        x, y, z = atom.xyz
        
        mol2_lines.append(f"{i+1:7d} {atom_name:<8s} {x:10.4f} {y:10.4f} {z:10.4f} {element_symbol:<5s} 1 {atom_key[2]:<8s} {atom.charge:8.4f}")
    
    # Bond section
    if num_bonds > 0:
        mol2_lines.append("@<TRIPOS>BOND")
        bond_count = 1
        for bond in chain.bonds:
            if bond.a in atom_key_to_index and bond.b in atom_key_to_index:
                atom1_idx = atom_key_to_index[bond.a] + 1
                atom2_idx = atom_key_to_index[bond.b] + 1
                
                if bond.aromatic:
                    bond_type = "ar"
                else:
                    bond_order = bond.order if hasattr(bond, 'order') and bond.order else 1
                    bond_type = str(min(max(bond_order, 1), 3))
                
                mol2_lines.append(f"{bond_count:7d} {atom1_idx:7d} {atom2_idx:7d} {bond_type:<7s}")
                bond_count += 1
    
    return '\n'.join(mol2_lines)

def visualize_chain_3d(chain: Chain, 
                      width: int = 800, 
                      height: int = 600,
                      style_dict: Optional[Dict] = None,
                      show_labels: bool = False,
                      color_by_element: bool = True,
                      background_color: str = 'white',
                      format_type: str = 'mol2') -> py3Dmol.view:
    """
    Visualize a Chain object in 3D using py3Dmol.
    
    Args:
        chain: Chain object from CIF parser containing atoms and bonds
        width: Width of the viewer in pixels
        height: Height of the viewer in pixels  
        style_dict: Custom styling for atoms (defaults to stick representation)
        show_labels: Whether to show atom labels
        color_by_element: Whether to color atoms by element type
        background_color: Background color of the viewer
        format_type: Format to use ('sdf' or 'mol2')
        
    Returns:
        py3Dmol viewer object ready for display
    """
    
    # Default styles
    if style_dict is None:
        style_dict = {'stick': {'radius': 0.1}, 'sphere': {'radius': 0.3}}
    
    # Create viewer
    viewer = py3Dmol.view(width=width, height=height)
    viewer.setBackgroundColor(background_color)
    
    # Convert chain to molecular format string
    if format_type.lower() == 'mol2':
        mol_string = chain_to_mol2_string(chain)
        file_format = 'mol2'
    else:
        mol_string = chain_to_sdf_string(chain)
        file_format = 'sdf'
    
    if not mol_string:
        print("Warning: No atoms with occupancy > 0 found in chain")
        return viewer
    
    # Add model from string
    viewer.addModel(mol_string, file_format)
    
    # Apply styling
    if color_by_element:
        # Element to color mapping (CPK colors)
        element_colors = {
            'H': 'white', 'C': 'gray', 'N': 'blue', 'O': 'red', 'S': 'yellow',
            'P': 'orange', 'F': 'green', 'Cl': 'green', 'Br': 'darkred',
            'I': 'purple', 'Fe': 'orange', 'Zn': 'gray', 'Ca': 'green',
            'Mg': 'darkgreen', 'Na': 'blue', 'K': 'violet', 'Cu': 'brown',
            'Mn': 'violet', 'Co': 'pink', 'Ni': 'lightgreen'
        }
        
        for element, color in element_colors.items():
            element_style = style_dict.copy()
            if 'stick' in element_style:
                element_style['stick']['color'] = color
            if 'sphere' in element_style:
                element_style['sphere']['color'] = color
            
            viewer.setStyle({'elem': element}, element_style)
    else:
        viewer.setStyle({}, style_dict)
    
    # Add labels if requested
    if show_labels:
        valid_atoms = [(atom_key, atom) for atom_key, atom in chain.atoms.items() if atom.occ > 0]
        for atom_key, atom in valid_atoms:
            atom_name = atom_key[3] if len(atom_key) > 3 else I2E.get(atom.element, 'X')
            viewer.addLabel(atom_name, {
                'position': {'x': atom.xyz[0], 'y': atom.xyz[1], 'z': atom.xyz[2]},
                'backgroundColor': 'white',
                'fontColor': 'black',
                'fontSize': 12
            })
    
    viewer.zoomTo()
    return viewer

def visualize_metal_site_3d(site_data: Dict,
                           width: int = 800,
                           height: int = 600,
                           highlight_metals: bool = True,
                           metal_color: str = 'red',
                           metal_size: float = 0.5) -> py3Dmol.view:
    """
    Visualize a metal binding site with metals highlighted.
    
    Args:
        site_data: Metal site dictionary from get_metal_sites()
        width: Width of the viewer in pixels
        height: Height of the viewer in pixels
        highlight_metals: Whether to highlight metal atoms differently
        metal_color: Color for metal atoms
        metal_size: Size multiplier for metal atoms
        
    Returns:
        py3Dmol viewer object ready for display
    """
    
    # Get the site chain
    site_chain = site_data['site_chain']
    
    # Create base visualization
    viewer = visualize_chain_3d(site_chain, width=width, height=height)
    
    if highlight_metals:
        # Highlight metal atoms with additional spheres
        for metal_atom_info in site_data['metal_atoms']:
            atom_key = metal_atom_info['atom_key']
            atom = site_chain.atoms.get(atom_key)
            
            if atom and atom.occ > 0:
                # Add larger, colored sphere for metal
                viewer.addSphere({
                    'center': {'x': atom.xyz[0], 'y': atom.xyz[1], 'z': atom.xyz[2]},
                    'radius': metal_size,
                    'color': metal_color,
                    'alpha': 0.8
                })
    
    viewer.zoomTo()
    return viewer

def visualize_protein_data_3d(
    protein_data,  # ProteinData object
    velocities: torch.Tensor = None,  # Optional (N_atoms, 3) velocity vectors
    width: int = 800,
    height: int = 600,
    highlight_metals: bool = True,
    metal_color: str = 'red',
    metal_size: float = 0.5,
    mask_color: str = 'grey',
    mask_size: float = 0.3,
    background_color: str = 'white',
    show_labels: bool = False,
    stick_radius: float = 0.1,
    sphere_radius: float = 0.3,
    highlight_atoms = None,
    highlight_color = 'pink',
    focus_atom: int = None,  # Atom index to focus on and highlight neighbors
    focus_color: str = 'magenta',
    neighbor_color: str = 'cyan',
    # Velocity visualization parameters
    show_velocities: bool = True,
    velocity_scale: float = 1.0,
    velocity_color: str = 'blue',
    velocity_radius: float = 0.05,
    velocity_threshold: float = 0.1,  # Min velocity magnitude to display
) -> py3Dmol.view:
    """
    Visualize ProteinData in 3D using py3Dmol with optional velocity vectors.
    
    Args:
        protein_data: ProteinData object containing atom and bond information
        velocities: Optional (N_atoms, 3) tensor of velocity vectors for each atom
        width: Width of the viewer in pixels
        height: Height of the viewer in pixels
        highlight_metals: Whether to highlight metal atoms differently
        metal_color: Color for metal atoms
        metal_size: Size multiplier for metal atoms
        mask_color: Color for masked atoms
        mask_size: Size multiplier for masked atoms
        background_color: Background color of the viewer
        show_labels: Whether to show atom labels
        stick_radius: Radius for stick bonds
        sphere_radius: Radius for atom spheres
        highlight_atoms: List/set of atom indices to highlight
        highlight_color: Color for highlighted atoms
        focus_atom: Index of atom to focus on (will be highlighted with X shape)
        focus_color: Color for the focus atom
        neighbor_color: Color for atoms connected to focus atom
        show_velocities: Whether to display velocity vectors
        velocity_scale: Scale factor for velocity vector length
        velocity_color: Color for velocity arrows
        velocity_radius: Radius for velocity arrows
        velocity_threshold: Minimum velocity magnitude to display arrow
        
    Returns:
        py3Dmol viewer object ready for display
        
    Raises:
        ValueError: If required features are missing from ProteinData
    """
    import py3Dmol
    import numpy as np
    import torch
    from metalsitenn.tokenizers import TOKENIZERS
    from metalsitenn.constants import ALL_METALS
    
    # Validate required features
    if protein_data.positions is None:
        raise ValueError("ProteinData must have positions")
    if protein_data.element is None:
        raise ValueError("ProteinData must have element")
    
    # Validate velocities if provided
    if type(velocities) == str and velocities == 'flow':
        assert protein_data.position_flow_labels is not None, "ProteinData must have position_flow_labels for flow visualization"
        assert protein_data.time is not None, "ProteinData must have time for flow visualization"
        vectors = protein_data.position_flow_labels * (1 - protein_data.time.item())
        velocities = vectors

    elif velocities is not None:
        positions = protein_data.positions
        if velocities.shape[0] != positions.shape[0]:
            raise ValueError(f"Velocities shape {velocities.shape} doesn't match positions shape {positions.shape}")
        if velocities.shape[1] != 3:
            raise ValueError(f"Velocities must have shape (N_atoms, 3), got {velocities.shape}")
    
    
    # Get basic data
    positions = protein_data.positions  # (N_atoms, 3)
    element_tokens = protein_data.element.squeeze(-1)  # (N_atoms,)
    n_atoms = len(positions)
    
    # Get tokenizer
    element_tokenizer = TOKENIZERS['element']
    
    # Decode elements from tokens
    elements = []
    is_masked = []
    for token in element_tokens:
        token_item = token.item()
        try:
            element = element_tokenizer.decode(token_item)
            if element == '<MASK>':
                elements.append('X')  # Use 'X' for unknown elements in visualization
                is_masked.append(True)
            elif element == '<UNK>':
                elements.append('X')
                is_masked.append(True)
            elif element == '<METAL>':
                elements.append('Fe')  # Use Fe as generic metal representation
                is_masked.append(False)
            else:
                elements.append(element)
                is_masked.append(False)
        except KeyError:
            elements.append('X')
            is_masked.append(True)
    
    # Check for masked atoms from training data
    masked_atoms = []
    # rely on above logic to determine if atoms are masked, thus atoms that were changed due to bert tweaking
    # get the color the changed to
    # if protein_data.atom_masked_mask is not None:
    #     masked_atoms = protein_data.atom_masked_mask.squeeze(-1).bool()
    
    # Find neighbors of focus atom if specified
    focus_neighbors = set()
    if focus_atom is not None and protein_data.edge_index is not None:
        edge_indices = protein_data.edge_index  # (E, 2)
        for edge_idx in range(len(edge_indices)):
            i, j = edge_indices[edge_idx]
            i, j = i.item(), j.item()
            if i == focus_atom:
                focus_neighbors.add(j)
            elif j == focus_atom:
                focus_neighbors.add(i)
    
    # Create viewer
    viewer = py3Dmol.view(width=width, height=height)
    viewer.setBackgroundColor(background_color)
    
    # Add atoms as spheres
    for i in range(n_atoms):
        pos = positions[i].numpy()
        element = elements[i]
        masked = is_masked[i] or (len(masked_atoms) > 0 and masked_atoms[i])
        
        # Determine color and size
        if highlight_atoms is not None and i in highlight_atoms:
            color = highlight_color
            radius = sphere_radius * 1.5
        elif masked:
            color = mask_color
            radius = mask_size
        elif i == focus_atom:
            color = focus_color
            radius = sphere_radius * 2.0  # Make focus atom larger
        elif i in focus_neighbors:
            color = neighbor_color
            radius = sphere_radius * 1.3
        else:
            # Use CPK colors for common elements
            cpk_colors = {
                'H': 'white', 'C': 'gray', 'N': 'blue', 'O': 'red', 'S': 'yellow',
                'P': 'orange', 'F': 'green', 'Cl': 'green', 'Br': 'darkred',
                'I': 'purple', 'Fe': 'orange', 'Zn': 'gray', 'Ca': 'green',
                'Mg': 'darkgreen', 'Na': 'blue', 'K': 'violet', 'Cu': 'brown',
                'Mn': 'violet', 'Co': 'pink', 'Ni': 'lightgreen'
            }
            color = cpk_colors.get(element, 'gray')
            radius = sphere_radius
            
        viewer.addSphere({
            'center': {'x': float(pos[0]), 'y': float(pos[1]), 'z': float(pos[2])},
            'radius': radius,
            'color': color,
            'alpha': 0.8
        })
        
        # Add X marker for focus atom
        if i == focus_atom:
            # Add X shape using two perpendicular cylinders
            x_size = radius * 1.5
            # First diagonal of X
            viewer.addCylinder({
                'start': {'x': float(pos[0] - x_size), 'y': float(pos[1] - x_size), 'z': float(pos[2])},
                'end': {'x': float(pos[0] + x_size), 'y': float(pos[1] + x_size), 'z': float(pos[2])},
                'radius': 0.05,
                'color': 'white',
                'alpha': 1.0
            })
            # Second diagonal of X
            viewer.addCylinder({
                'start': {'x': float(pos[0] - x_size), 'y': float(pos[1] + x_size), 'z': float(pos[2])},
                'end': {'x': float(pos[0] + x_size), 'y': float(pos[1] - x_size), 'z': float(pos[2])},
                'radius': 0.05,
                'color': 'white',
                'alpha': 1.0
            })
        
        # Add labels if requested
        if show_labels:
            label_text = f"{element}{i}" if not masked else f"MASK{i}"
            if protein_data.atom_name is not None and i < len(protein_data.atom_name):
                label_text = f"{protein_data.atom_name[i]}"
            viewer.addLabel(label_text, {
                'position': {'x': float(pos[0]), 'y': float(pos[1]), 'z': float(pos[2])},
                'backgroundColor': 'white',
                'fontColor': 'black',
                'fontSize': 10
            })
    
    # Add velocity vectors if provided and requested
    if velocities is not None and show_velocities:
        velocities_np = velocities.numpy()
        
        for i in range(n_atoms):
            pos = positions[i].numpy()
            vel = velocities_np[i]
            
            # Calculate velocity magnitude
            vel_magnitude = np.linalg.norm(vel)
            
            # Only show arrow if velocity magnitude is above threshold
            if vel_magnitude > velocity_threshold:
                # Scale velocity vector
                scaled_vel = vel * velocity_scale
                
                # Calculate end position
                end_pos = pos + scaled_vel
                
                # Add arrow from atom position in direction of velocity
                viewer.addArrow({
                    'start': {'x': float(pos[0]), 'y': float(pos[1]), 'z': float(pos[2])},
                    'end': {'x': float(end_pos[0]), 'y': float(end_pos[1]), 'z': float(end_pos[2])},
                    'radius': velocity_radius,
                    'color': velocity_color,
                    'alpha': 0.8
                })
                
                # Optionally add velocity magnitude as label
                if show_labels:
                    vel_label_pos = pos + scaled_vel * 0.5  # Midpoint of arrow
                    viewer.addLabel(f"v={vel_magnitude:.2f}", {
                        'position': {'x': float(vel_label_pos[0]), 'y': float(vel_label_pos[1]), 'z': float(vel_label_pos[2])},
                        'backgroundColor': 'lightblue',
                        'fontColor': 'black',
                        'fontSize': 8
                    })
    
    # # Add bonds from topology (prioritized source)
    # if protein_data.topology is not None and 'bonds' in protein_data.topology:
    #     bonds = protein_data.topology['bonds']  # (N_bonds, 2)
        
    #     for bond_idx in range(len(bonds)):
    #         i, j = bonds[bond_idx]
    #         i, j = i.item(), j.item()
            
    #         # Skip if atoms are masked
    #         if (len(masked_atoms) > 0 and (masked_atoms[i] or masked_atoms[j])):
    #             continue
                
    #         # Add bond as cylinder
    #         pos_i = positions[i].numpy()
    #         pos_j = positions[j].numpy()
            
    #         viewer.addCylinder({
    #             'start': {'x': float(pos_i[0]), 'y': float(pos_i[1]), 'z': float(pos_i[2])},
    #             'end': {'x': float(pos_j[0]), 'y': float(pos_j[1]), 'z': float(pos_j[2])},
    #             'radius': stick_radius,
    #             'color': 'gray',
    #             'alpha': 0.8
    #         })
    
    # Fallback: Add bonds from edge features if topology unavailable
    if protein_data.bond_order is not None and protein_data.edge_index is not None:
        bond_orders = protein_data.bond_order.squeeze(-1)  # (E,)
        edge_indices = protein_data.edge_index  # (E, 2)
        
        # Get bond tokenizer
        bond_tokenizer = TOKENIZERS['bond_order']
        
        # Get non-bonded token ID for comparison
        non_bonded_id = bond_tokenizer.non_bonded_token_id
        mask_token_id = bond_tokenizer.mask_token_id if hasattr(bond_tokenizer, 'mask_token_id') else None
        
        # Add bonds
        for edge_idx in range(len(edge_indices)):
            i, j = edge_indices[edge_idx]
            bond_token = bond_orders[edge_idx].item()
            
            # Skip non-bonds and masked bonds
            if bond_token == non_bonded_id:
                continue
            if mask_token_id is not None and bond_token == mask_token_id:
                continue
                
            # Decode bond order
            try:
                bond_order = bond_tokenizer.decode(bond_token)
            except KeyError:
                continue
                
            # Determine bond style based on order
            if bond_order == 1:
                bond_radius = stick_radius
            elif bond_order == 2:
                bond_radius = stick_radius * 1.2
            elif bond_order == 3:
                bond_radius = stick_radius * 1.4
            else:
                bond_radius = stick_radius
                
            # Add bond as cylinder
            pos_i = positions[i].numpy()
            pos_j = positions[j].numpy()
            
            viewer.addCylinder({
                'start': {'x': float(pos_i[0]), 'y': float(pos_i[1]), 'z': float(pos_i[2])},
                'end': {'x': float(pos_j[0]), 'y': float(pos_j[1]), 'z': float(pos_j[2])},
                'radius': bond_radius,
                'color': 'gray',
                'alpha': 0.8
            })
    
    viewer.zoomTo()
    return viewer
    
def get_emission_time_job_from_codecarbon_log(emissions_file: str, project_name: str) -> pd.DataFrame:
    """
    Parse the CodeCarbon emissions log file to extract the time and job ID for each emission. Assumes most recent emissions are at the end of the file.
    
    Args:
        emissions_file (str): Path to the CodeCarbon emissions log file.
        project_name (str): Name of the project to extract emissions for.
    
    Returns:
        pd.DataFrame: DataFrame containing the time and job ID for each emission.
    """
    df = pd.read_csv(emissions_file)
    df = df[df["project_name"] == project_name]
    df["timestamp"] = pd.to_datetime(df["timestamp"])
    df = df.sort_values(by='timestamp', ascending=False)

    if len(df) == 0:
        raise ValueError(f"No emissions found for project {project_name} in file {emissions_file}")

    duration = str(df['duration'].iloc[0])
    emissions = str(df['emissions'].iloc[0])

    return duration, emissions

def compute_balanced_atom_weights_from_frequencies(freq_dict: Dict[str, float], temperature: float = 1.0) -> Dict[str, float]:
    """Convert frequency dictionary to balanced weight dictionary with temperature scaling.
    
    Temperature closer to 0 makes weights more uniform, while higher temperatures 
    increase the relative weighting of rare tokens.
    
    Args:
        freq_dict: Dictionary mapping tokens to their frequencies
        temperature: Factor to scale frequency differences. Range (0, inf).
            temperature -> 0: weights become uniform
            temperature = 1: standard inverse frequency weights
            temperature > 1: amplifies differences between rare/common tokens
        
    Returns:
        Dictionary mapping tokens to weight values that average to 1.0
    """
    # Apply temperature scaling to frequencies
    scaled_freqs = {k: v**temperature for k,v in freq_dict.items()}
    
    # Convert frequencies to inverse weights
    weights = {k: 1/v if v > 0 else 1.0 for k,v in scaled_freqs.items()}
    
    # Normalize to mean 1.0
    mean_weight = sum(weights.values()) / len(weights)
    return {k: w/mean_weight for k,w in weights.items()}

