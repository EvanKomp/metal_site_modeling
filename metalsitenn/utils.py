# metalsitenn/utils.py
'''
* Author: Evan Komp
* Created: 11/26/2024
* Company: National Renewable Energy Lab, Bioeneergy Science and Technology
* License: MIT
'''
import py3Dmol
from typing import Dict, Optional
from metalsitenn.placer_modules.cifutils import Chain
from metalsitenn.constants import I2E
import pandas as pd
import numpy as np
from dataclasses import dataclass


@dataclass
class ParamsObj:
    """Wraps dict of dicts to allow attribute access to nested dicts."""
    def __init__(self, upper_dict):
        for k, v in upper_dict.items():
            if isinstance(v, dict):
                setattr(self, k, ParamsObj(v))
            else:
                setattr(self, k, v)

    def __getitem__(self, key):
        return getattr(self, key)
    
    def __repr__(self):
        return str(self.__dict__)
    
    @property
    def param_names(self):
        return list(self.__dict__.keys())
    

def make_jsonable(dic):
    """Convert numerics into int or float for JSON serialization."""
    new_dic = {}
    for k, v in dic.items():
        if isinstance(v, str):
            new_dic[k] = v
        # it may be a numeric but not a base type like numpy or something
        # first check it its a whole number
        if int(v) == v:
            new_dic[k] = int(v)
        else:
            new_dic[k] = float(v)
    return new_dic
         

def chain_to_sdf_string(chain: Chain) -> str:
    """
    Convert a Chain object to SDF (Structure Data Format) string.
    SDF format includes explicit bond information that py3Dmol can parse.
    
    Args:
        chain: Chain object from CIF parser containing atoms and bonds
        
    Returns:
        SDF format string
    """
    
    # Filter atoms with occupancy > 0 and create atom list
    valid_atoms = [(atom_key, atom) for atom_key, atom in chain.atoms.items() if atom.occ > 0]
    
    if not valid_atoms:
        return ""
    
    # Create atom key to index mapping for bond references
    atom_key_to_index = {atom_key: i for i, (atom_key, atom) in enumerate(valid_atoms)}
    
    # SDF Header (molecule name, program info, comment)
    sdf_lines = [
        chain.id or "molecule",  # Molecule name
        "Generated by metalsitenn",  # Program info
        "Converted from CIF Chain object",  # Comment
        ""  # Empty line
    ]
    
    # Counts line: aaabbblllfffcccsssxxxrrrpppiiimmmvvvvvv
    # aaa = number of atoms, bbb = number of bonds
    num_atoms = len(valid_atoms)
    num_bonds = len([b for b in chain.bonds if b.a in atom_key_to_index and b.b in atom_key_to_index])
    
    counts_line = f"{num_atoms:3d}{num_bonds:3d}  0  0  0  0  0  0  0  0999 V2000"
    sdf_lines.append(counts_line)
    
    # Atom block: xxxxx.xxxxyyyyy.yyyyzzzzz.zzzz aaaddccchhhmmmvvvHHHrrriiisssbbbbbbbbbbbbeeeeeeeeeeee
    for atom_key, atom in valid_atoms:
        element_symbol = I2E.get(atom.element, 'X')
        
        # Format coordinates to SDF specification (10.4f format)
        x, y, z = atom.xyz
        atom_line = f"{x:10.4f}{y:10.4f}{z:10.4f} {element_symbol:<3s} 0  {atom.charge:3d}  0  0  0  0  0  0  0  0  0  0"
        sdf_lines.append(atom_line)
    
    # Bond block: 111222tttsssxxxrrrccc
    # 111 = first atom number, 222 = second atom number, ttt = bond type
    for bond in chain.bonds:
        if bond.a in atom_key_to_index and bond.b in atom_key_to_index:
            atom1_idx = atom_key_to_index[bond.a] + 1  # SDF uses 1-based indexing
            atom2_idx = atom_key_to_index[bond.b] + 1
            bond_order = bond.order if hasattr(bond, 'order') and bond.order else 1
            
            # Limit bond order to valid SDF range (1-3, 4 for aromatic)
            if bond.aromatic:
                bond_type = 4
            else:
                bond_type = min(max(bond_order, 1), 3)
            
            bond_line = f"{atom1_idx:3d}{atom2_idx:3d}{bond_type:3d}  0  0  0  0"
            sdf_lines.append(bond_line)
    
    # End of molecule marker
    sdf_lines.append("M  END")
    sdf_lines.append("$$$$")
    
    return '\n'.join(sdf_lines)

def chain_to_mol2_string(chain: Chain) -> str:
    """
    Convert a Chain object to MOL2 format string as an alternative to SDF.
    MOL2 format also includes explicit bond information.
    
    Args:
        chain: Chain object from CIF parser containing atoms and bonds
        
    Returns:
        MOL2 format string
    """
    
    # Filter atoms with occupancy > 0
    valid_atoms = [(atom_key, atom) for atom_key, atom in chain.atoms.items() if atom.occ > 0]
    
    if not valid_atoms:
        return ""
    
    # Create atom key to index mapping
    atom_key_to_index = {atom_key: i for i, (atom_key, atom) in enumerate(valid_atoms)}
    
    mol2_lines = ["@<TRIPOS>MOLECULE"]
    mol2_lines.append(chain.id or "molecule")
    
    num_atoms = len(valid_atoms)
    num_bonds = len([b for b in chain.bonds if b.a in atom_key_to_index and b.b in atom_key_to_index])
    
    mol2_lines.append(f"{num_atoms} {num_bonds} 0 0 0")
    mol2_lines.append("SMALL")
    mol2_lines.append("NO_CHARGES")
    mol2_lines.append("")
    
    # Atom section
    mol2_lines.append("@<TRIPOS>ATOM")
    for i, (atom_key, atom) in enumerate(valid_atoms):
        element_symbol = I2E.get(atom.element, 'X')
        atom_name = atom_key[3] if len(atom_key) > 3 else f"{element_symbol}{i+1}"
        x, y, z = atom.xyz
        
        mol2_lines.append(f"{i+1:7d} {atom_name:<8s} {x:10.4f} {y:10.4f} {z:10.4f} {element_symbol:<5s} 1 {atom_key[2]:<8s} {atom.charge:8.4f}")
    
    # Bond section
    if num_bonds > 0:
        mol2_lines.append("@<TRIPOS>BOND")
        bond_count = 1
        for bond in chain.bonds:
            if bond.a in atom_key_to_index and bond.b in atom_key_to_index:
                atom1_idx = atom_key_to_index[bond.a] + 1
                atom2_idx = atom_key_to_index[bond.b] + 1
                
                if bond.aromatic:
                    bond_type = "ar"
                else:
                    bond_order = bond.order if hasattr(bond, 'order') and bond.order else 1
                    bond_type = str(min(max(bond_order, 1), 3))
                
                mol2_lines.append(f"{bond_count:7d} {atom1_idx:7d} {atom2_idx:7d} {bond_type:<7s}")
                bond_count += 1
    
    return '\n'.join(mol2_lines)

def visualize_chain_3d(chain: Chain, 
                      width: int = 800, 
                      height: int = 600,
                      style_dict: Optional[Dict] = None,
                      show_labels: bool = False,
                      color_by_element: bool = True,
                      background_color: str = 'white',
                      format_type: str = 'mol2') -> py3Dmol.view:
    """
    Visualize a Chain object in 3D using py3Dmol.
    
    Args:
        chain: Chain object from CIF parser containing atoms and bonds
        width: Width of the viewer in pixels
        height: Height of the viewer in pixels  
        style_dict: Custom styling for atoms (defaults to stick representation)
        show_labels: Whether to show atom labels
        color_by_element: Whether to color atoms by element type
        background_color: Background color of the viewer
        format_type: Format to use ('sdf' or 'mol2')
        
    Returns:
        py3Dmol viewer object ready for display
    """
    
    # Default styles
    if style_dict is None:
        style_dict = {'stick': {'radius': 0.1}, 'sphere': {'radius': 0.3}}
    
    # Create viewer
    viewer = py3Dmol.view(width=width, height=height)
    viewer.setBackgroundColor(background_color)
    
    # Convert chain to molecular format string
    if format_type.lower() == 'mol2':
        mol_string = chain_to_mol2_string(chain)
        file_format = 'mol2'
    else:
        mol_string = chain_to_sdf_string(chain)
        file_format = 'sdf'
    
    if not mol_string:
        print("Warning: No atoms with occupancy > 0 found in chain")
        return viewer
    
    # Add model from string
    viewer.addModel(mol_string, file_format)
    
    # Apply styling
    if color_by_element:
        # Element to color mapping (CPK colors)
        element_colors = {
            'H': 'white', 'C': 'gray', 'N': 'blue', 'O': 'red', 'S': 'yellow',
            'P': 'orange', 'F': 'green', 'Cl': 'green', 'Br': 'darkred',
            'I': 'purple', 'Fe': 'orange', 'Zn': 'gray', 'Ca': 'green',
            'Mg': 'darkgreen', 'Na': 'blue', 'K': 'violet', 'Cu': 'brown',
            'Mn': 'violet', 'Co': 'pink', 'Ni': 'lightgreen'
        }
        
        for element, color in element_colors.items():
            element_style = style_dict.copy()
            if 'stick' in element_style:
                element_style['stick']['color'] = color
            if 'sphere' in element_style:
                element_style['sphere']['color'] = color
            
            viewer.setStyle({'elem': element}, element_style)
    else:
        viewer.setStyle({}, style_dict)
    
    # Add labels if requested
    if show_labels:
        valid_atoms = [(atom_key, atom) for atom_key, atom in chain.atoms.items() if atom.occ > 0]
        for atom_key, atom in valid_atoms:
            atom_name = atom_key[3] if len(atom_key) > 3 else I2E.get(atom.element, 'X')
            viewer.addLabel(atom_name, {
                'position': {'x': atom.xyz[0], 'y': atom.xyz[1], 'z': atom.xyz[2]},
                'backgroundColor': 'white',
                'fontColor': 'black',
                'fontSize': 12
            })
    
    viewer.zoomTo()
    return viewer

def visualize_metal_site_3d(site_data: Dict,
                           width: int = 800,
                           height: int = 600,
                           highlight_metals: bool = True,
                           metal_color: str = 'red',
                           metal_size: float = 0.5) -> py3Dmol.view:
    """
    Visualize a metal binding site with metals highlighted.
    
    Args:
        site_data: Metal site dictionary from get_metal_sites()
        width: Width of the viewer in pixels
        height: Height of the viewer in pixels
        highlight_metals: Whether to highlight metal atoms differently
        metal_color: Color for metal atoms
        metal_size: Size multiplier for metal atoms
        
    Returns:
        py3Dmol viewer object ready for display
    """
    
    # Get the site chain
    site_chain = site_data['site_chain']
    
    # Create base visualization
    viewer = visualize_chain_3d(site_chain, width=width, height=height)
    
    if highlight_metals:
        # Highlight metal atoms with additional spheres
        for metal_atom_info in site_data['metal_atoms']:
            atom_key = metal_atom_info['atom_key']
            atom = site_chain.atoms.get(atom_key)
            
            if atom and atom.occ > 0:
                # Add larger, colored sphere for metal
                viewer.addSphere({
                    'center': {'x': atom.xyz[0], 'y': atom.xyz[1], 'z': atom.xyz[2]},
                    'radius': metal_size,
                    'color': metal_color,
                    'alpha': 0.8
                })
    
    viewer.zoomTo()
    return viewer
    
def get_emission_time_job_from_codecarbon_log(emissions_file: str, project_name: str) -> pd.DataFrame:
    """
    Parse the CodeCarbon emissions log file to extract the time and job ID for each emission. Assumes most recent emissions are at the end of the file.
    
    Args:
        emissions_file (str): Path to the CodeCarbon emissions log file.
        project_name (str): Name of the project to extract emissions for.
    
    Returns:
        pd.DataFrame: DataFrame containing the time and job ID for each emission.
    """
    df = pd.read_csv(emissions_file)
    df = df[df["project_name"] == project_name]
    df["timestamp"] = pd.to_datetime(df["timestamp"])
    df = df.sort_values(by='timestamp', ascending=False)

    if len(df) == 0:
        raise ValueError(f"No emissions found for project {project_name} in file {emissions_file}")

    duration = str(df['duration'].iloc[0])
    emissions = str(df['emissions'].iloc[0])

    return duration, emissions

def compute_balanced_atom_weights_from_frequencies(freq_dict: Dict[str, float], temperature: float = 1.0) -> Dict[str, float]:
    """Convert frequency dictionary to balanced weight dictionary with temperature scaling.
    
    Temperature closer to 0 makes weights more uniform, while higher temperatures 
    increase the relative weighting of rare tokens.
    
    Args:
        freq_dict: Dictionary mapping tokens to their frequencies
        temperature: Factor to scale frequency differences. Range (0, inf).
            temperature -> 0: weights become uniform
            temperature = 1: standard inverse frequency weights
            temperature > 1: amplifies differences between rare/common tokens
        
    Returns:
        Dictionary mapping tokens to weight values that average to 1.0
    """
    # Apply temperature scaling to frequencies
    scaled_freqs = {k: v**temperature for k,v in freq_dict.items()}
    
    # Convert frequencies to inverse weights
    weights = {k: 1/v if v > 0 else 1.0 for k,v in scaled_freqs.items()}
    
    # Normalize to mean 1.0
    mean_weight = sum(weights.values()) / len(weights)
    return {k: w/mean_weight for k,w in weights.items()}

